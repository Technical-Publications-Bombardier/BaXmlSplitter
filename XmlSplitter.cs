using System.Diagnostics;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using System.Xml;

namespace BaXmlSplitter
{
    /// <summary>
    ///  The main form for the XML splitting tool.
    ///  TODO: Allow full automation 
    ///     TODO: by allocating states in-progress from SME's.
    ///  TODO: Verify that the states loaded provide full coverage for all UOW in the XML.
    /// </summary>
    /// <seealso cref="Form" />
    public partial class XmlSplitter : Form
    {
        /// <summary>The log file path
        /// for the XML splitting.</summary>
        private readonly string logFile;
        /// <summary>The HTML splitting report
        /// that is generated by the tool after the splitting operation is completed.</summary>
        private string? splittingReportHtml;
        /// <summary>The report object that is used to keep a record of all the nodes that were split off from the XML. 
        /// Nodes are recorded as <see cref="XmlSplitReportEntry" /> objects.</summary>
        /// <seealso cref="XmlSplitReportEntry" />
        private XmlSplitReport? report;
        /// <summary>
        /// The path to the source XML file on which the split will be performed.
        /// </summary>
        private string? xmlSourceFile;
        private string? XmlSourceFileBaseName => XmlSplitterHelpers.XmlFilenameRe.Replace(Path.GetFileNameWithoutExtension(xmlSourceFile ?? string.Empty), m => TerminusChars().Replace(m.Groups[1].Value, string.Empty));

        /// <summary>The string content of the XML file on which the split will be performed. This is 
        /// loaded into memory as soon as the XML is selected.</summary>
        private string? xmlContent;
        /// <summary>The XML object that will parse the XML content. </summary><seealso cref="BaXmlDocument" />
        private readonly BaXmlDocument xml = new()
        {
            ResolveEntities = false
        };
        /// <summary>The path to the file that contains the work states for the units of work (UOW) in the XML.</summary>
        private string? uowStatesFile;
        /// <summary>
        /// The content of the UOW states file. This is loaded into memory as soon as the UOW states file is selected.
        /// </summary>
        private string? uowContent;
        /// <summary>
        /// The directory to which the split XML files will be written. <see cref="XmlSplitterHelpers.DefaultOutputDir">By default</see>, this will be the <c>"WIP"</c> directory in the same directory as the source XML file.
        /// </summary>
        private string? outputDir;
        /// <summary>
        /// The XPath string that would be used to select the nodes to split from the XML. This is calculated from the tag names and key values in the UOW states file.
        /// </summary>
        private string? xpath;
        /// <summary>A dictionary of all the states in any CSDB program (GXPROD, CTALPROD, B_IFM, CH604PROD, LJ4045PROD).</summary>
        private Dictionary<XmlSplitterHelpers.CsdbProgram, Dictionary<int, UowState>>? statesPerProgram;
        /// <summary>The CSDB element names eligible for importing to RWS Contenta.</summary>
        private Dictionary<XmlSplitterHelpers.CsdbProgram, Dictionary<string, string[]>>? checkoutItems;
        /// <summary>The lookup table for manual type from docnbr.</summary>
        private Dictionary<XmlSplitterHelpers.CsdbProgram, Dictionary<string, string>>? manualFromDocnbr;
        /// <summary>The CSDB program (GXPROD, CTALPROD, B_IFM, CH604PROD, LJ4045PROD)
        /// for the manual.</summary>
        private string? program;
        /// <summary>The fully populated unit-of-work states that are selected by the user for export.</summary>
        private IEnumerable<UowState>? fullyQualifiedSelectedStates;

        /// <summary>
        /// Initializes a new instance of the <see cref="XmlSplitter"/> class.
        /// </summary>
        public XmlSplitter()
        {
            InitializeComponent();
            logFile = Path.Combine(Path.GetTempPath(), $"BaXmlSplitter-{DateTime.Now:yyyy-MM-dd-HH-mm-ss-fffffff}.log");
            File.Move(Path.GetTempFileName(), logFile);
            logTextBox.SuspendLayout();
            logTextBox.Font = new Font("Cascadia Mono", 10);
            logTextBox.SelectAll();
            logTextBox.SelectionIndent += 10;
            logTextBox.SelectionRightIndent += 10;
            logTextBox.DeselectAll();
            logTextBox.ResumeLayout();
            programsComboBox.SuspendLayout();
            programsComboBox.AutoCompleteCustomSource.AddRange(Enum.GetNames<XmlSplitterHelpers.CsdbProgram>());
            programsComboBox.Items.AddRange(Enum.GetNames<XmlSplitterHelpers.CsdbProgram>().Cast<object>().ToArray());
            programsComboBox.ResumeLayout();
            WriteLog($"Started XML splitting tool with real time log at '{logFile}'");
        }

        /// <summary>
        /// Handles the Load event of the XmlSplitter control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private async void XmlSplitter_Load(object sender, EventArgs e)
        {
            CheckExecuteSplitIsReady(sender, e);  // just disable execButton on load
            await Task.Run(() =>
            {
                statesPerProgram = XmlSplitterHelpers.DeserializeStates();
                checkoutItems = XmlSplitterHelpers.DeserializeCheckoutItems();
                manualFromDocnbr = XmlSplitterHelpers.DeserializeDocnbrManualFromProgram();
            }).ConfigureAwait(true);
            WriteLog("Finished initializing.");
        }

        /// <summary>
        /// Writes the log.
        /// </summary>
        /// <param name="message">The message.</param>
        /// <param name="severity">The severity.</param>
        /// <param name="noNewLine">if set to <c>true</c> [no new line].</param>
        /// <param name="skipFile">if set to <c>true</c> [skip file].</param>
        /// <returns></returns>
        private void WriteLog(string message, Severity severity = Severity.Hint, bool noNewLine = false, bool skipFile = false)
        {
            if (logTextBox.InvokeRequired)
            {
                logTextBox.Invoke(LogDelegate);
            }
            else
            {
                LogDelegate();
            }

            return;

            void LogDelegate()
            {
                var timestamped = string.Format(CultureInfo.InvariantCulture, "{0}:\t{1}", DateTime.Now.ToString(XmlSplitterHelpers.LogTimestampFormat, CultureInfo.InvariantCulture), message + (noNewLine ? "" : Environment.NewLine));
                if (!skipFile)
                {
                    try
                    {
                        using var log = File.Open(logFile, FileMode.Append);
                        try
                        {

                            using StreamWriter logWriter = new(log);
                            try
                            {
                                logWriter.Write(timestamped);
                                logWriter.Flush();
                            }
                            finally
                            {
                                logWriter.Close();
                                logWriter.Dispose();
                            }
                        }
                        finally
                        {
                            log.Close();
                            log.Dispose();
                        }
                    }
                    catch (Exception e)
                    {
                        WriteLog($"Unable to write to log file at {logFile}: {e.Message}", Severity.Error, false, true);
                    }
                }
                logTextBox.SuspendLayout();
                logTextBox.SelectionColor = severity switch
                {
                    Severity.Hint => Color.Lime,
                    Severity.Warning => Color.Gold,
                    Severity.Error => Color.OrangeRed,
                    Severity.Fatal => Color.Red,
                    _ => logTextBox.SelectionColor
                };
                logTextBox.AppendText(timestamped);
                logTextBox.ScrollToCaret();
                logTextBox.ResumeLayout();
            }
        }

        /// <summary>
        /// Browses for the XML to split.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="EventArgs" /> instance containing the event data.</param>
        /// <returns></returns>
        private void BrowseXml(object sender, EventArgs e)
        {
            var filename = XmlSplitterHelpers.BrowseForFile(filter: "Flight or maintenance manual|*.xml", startingPath: xmlSelectTextBox.Text);
            xmlSelectTextBox.Text = filename;
            XmlSelectTextBox_TextChanged(sender, e);
        }

        /// <summary>
        /// Browses for the current states file.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private void BrowseUow(object sender, EventArgs e)
        {
            var filename = XmlSplitterHelpers.BrowseForFile(filter: "UOW states file|*.*", startingPath: uowTextBox.Text);
            while (Path.GetExtension(filename).Equals(".xml", StringComparison.OrdinalIgnoreCase) && !XmlSplitterHelpers.ShowConfirmationBox($"The chosen UOW states file {Path.GetFileName(filename)} appears to be an XML file, not a file generated by the $LAUNCH tool in Unix. Proceed anyway?", "XML chosen as UOW states file"))
            {
                filename = XmlSplitterHelpers.BrowseForFile(filter: "UOW states file|*.*", startingPath: uowTextBox.Text);
            }
            uowTextBox.Text = filename;
            UowStatesTextBox_TextChanged(sender, e);
        }

        /// <summary>
        /// Browses for output directory.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private void BrowseOutDir(object sender, EventArgs e)
        {
            using FolderBrowserDialog dialog = new();
            if (dialog.ShowDialog() != DialogResult.OK) return;
            outDirTextBox.Text = dialog.SelectedPath;
            OutDirTextBox_TextChanged(sender, e);
        }

        /// <summary>
        /// Handles the TextChanged event of the XPathTextBox control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private void XPathTextBox_TextChanged(object sender, EventArgs e)
        {
            if (xpathTextBox.InvokeRequired)
            {
                xpathTextBox.Invoke(XpathTextBoxDelegate);
            }
            else
            {
                XpathTextBoxDelegate();
            }

            return;

            void XpathTextBoxDelegate()
            {
                xpathTextBox.SuspendLayout();
                xpathLabel.SuspendLayout();
                xpathGroupBox.SuspendLayout();
                if (!string.IsNullOrEmpty(xpath) && (!xpathTextBox.Visible || !xpathGroupBox.Visible || !xpathLabel.Visible))
                {
                    xpathTextBox.Text = xpath;
                    xpathTextBox.Visible = true;
                    xpathGroupBox.Visible = true;
                    xpathLabel.Visible = true;
                }
                else
                {
                    xpathTextBox.Visible = false;
                    xpathGroupBox.Visible = false;
                    xpathLabel.Visible = false;
                }
                xpathGroupBox.ResumeLayout();
                xpathLabel.ResumeLayout();
                xpathTextBox.ResumeLayout();
            }
        }
        /// <summary>
        /// Handles the TextChanged event of the XmlSelectTextBox control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private async void XmlSelectTextBox_TextChanged(object sender, EventArgs e)
        {
            xmlSelectTextBox.Select(xmlSelectTextBox.Text.Length, 0);
            try
            {
                if (File.Exists(xmlSelectTextBox.Text))
                {
                    if (!string.IsNullOrEmpty(xmlSourceFile) && Path.GetFullPath(xmlSourceFile) == Path.GetFullPath(xmlSelectTextBox.Text))
                    {
                        return;
                    }

                    xmlSourceFile = Path.GetFullPath(xmlSelectTextBox.Text);
                    var container = Path.GetDirectoryName(xmlSourceFile);
                    if (container is not null)
                    {
                        outDirTextBox.Text = Path.Combine(container, XmlSplitterHelpers.DefaultOutputDir);
                        OutDirTextBox_TextChanged(sender, e);
                    }
                    WriteLog(string.Format(CultureInfo.InvariantCulture, "Reading XML file '{0}'", Path.GetFileName(xmlSourceFile)));
                    //TextFileChosen(out xmlContent, xmlSelectTextBox.Text, xmlSelectTextBox, "XML");
                    xmlContent = await File.ReadAllTextAsync(xmlSourceFile).ConfigureAwait(true);
                    if (string.IsNullOrEmpty(xmlContent) && new FileInfo(xmlSourceFile).Length > 0)
                    {
                        WriteLog("Unable to read XML file. Please check that the file is available and not locked by another process.", Severity.Error);
                    }
                    else
                    {
                        WriteLog("Done reading XML file into memory.");
                    }
                }
                else
                {
                    WriteLog("Please select a valid XML file.", Severity.Warning);
                }
            }
            catch (Exception exception)
            {
                WriteLog(exception.Message, Severity.Error);
            }
        }
        /// <summary>
        /// Handles the TextChanged event of the UowStatesTextBox control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private async void UowStatesTextBox_TextChanged(object sender, EventArgs e)
        {
            uowTextBox.Select(uowTextBox.Text.Length, 0);
            try
            {
                if (File.Exists(uowTextBox.Text) && (!XmlSplitterHelpers.IsBinary(uowTextBox.Text) || XmlSplitterHelpers.ShowConfirmationBox(string.Format(CultureInfo.InvariantCulture, "The file at '{0}' appears to be a binary file, not text. Continue?", uowTextBox.Text), string.Format(CultureInfo.InvariantCulture, "File '{0}' is not text", Path.GetFileName(uowTextBox.Text)))))
                {

                    if (!string.IsNullOrEmpty(uowStatesFile) && uowStatesFile == uowTextBox.Text)
                    {
                        return;
                    }
                    uowStatesFile = uowTextBox.Text;
                    WriteLog($"Reading UOW file '{Path.GetFileName(uowStatesFile)}'");
                    uowContent = await File.ReadAllTextAsync(uowStatesFile).ConfigureAwait(true);
                    xpath = string.Empty;
                    XPathTextBox_TextChanged(sender, e);
                    if (string.IsNullOrEmpty(uowContent) && new FileInfo(uowStatesFile).Length > 0)
                    {
                        WriteLog("Unable to read UOW states file. Please check that the file is available and not locked by another process.", Severity.Error);
                    }
                    else
                    {
                        WriteLog("Done reading UOW file into memory.");
                    }
                }
                else
                {
                    WriteLog("Please provide a valid path", Severity.Warning);
                }
            }
            catch (Exception exception)
            {
                WriteLog(exception.Message, Severity.Error);
            }
        }

        /// <summary>
        /// Handles the TextChanged event of the OutDirTextBox control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private void OutDirTextBox_TextChanged(object sender, EventArgs e)
        {
            outDirTextBox.Select(outDirTextBox.Text.Length, 0);
            if (outputDir == outDirTextBox.Text) return;
            // if the out dir does not exist, set outDirWillBeCreated.Visible to true
            try
            {
                outputDir = outDirTextBox.Text;
                outDirWillBeCreated.SuspendLayout();
                if (!Directory.Exists(outputDir))
                {
                    outDirWillBeCreated.Enabled = outDirWillBeCreated.Visible = true;
                    WriteLog("Output directory will be created.");
                }
                else
                {
                    outDirWillBeCreated.Enabled = outDirWillBeCreated.Visible = false;
                }
                outDirWillBeCreated.ResumeLayout();
                WriteLog($"Selected units of work will be written to {outputDir}");
            }
            catch (Exception exception)
            {
                WriteLog(exception.Message, Severity.Error);
            }
            if (Path.GetDirectoryName(outputDir) is { } outputDirPath && Path.GetDirectoryName(outputDirPath) is { } outputDirParent && Path.GetFileNameWithoutExtension(outputDirPath) is { } wipDirLeafBase)
            {
                wipFolderWatcher.Path = outputDirParent;
                wipFolderWatcher.Filter = wipDirLeafBase;
                wipFolderWatcher.EnableRaisingEvents = true;
            }
            else
            {
                wipFolderWatcher.Path = string.Empty;
                wipFolderWatcher.Filter = string.Empty;
                wipFolderWatcher.EnableRaisingEvents = false;
            }
        }
        /// <summary>
        /// The XML is selected.
        /// </summary>
        /// <returns>Returns <c>true</c> if <see cref="xmlSourceFile" /> and <see cref="xmlContent" /> are both not null or empty, <c>false</c> otherwise.</returns>
        internal bool XmlIsSelected()
        {
            return !string.IsNullOrEmpty(xmlSourceFile) && !string.IsNullOrEmpty(xmlContent);
        }
        /// <summary>
        /// Units of work states for export are selected.
        /// </summary>
        /// <returns>Returns <c>true</c> if <see cref="uowStatesFile" /> and <see cref="uowContent" /> are both not null or empty, <c>false</c> otherwise.</returns>
        internal bool UowIsSelected()
        {
            return !string.IsNullOrEmpty(uowStatesFile) && !string.IsNullOrEmpty(uowContent);
        }
        /// <summary>
        /// Output directory is selected.
        /// </summary>
        /// <returns>Returns <c>true</c> if <see cref="outputDir"/> is not null or empty, <c>false</c> otherwise.</returns>
        internal bool OutDirIsSelected()
        {
            return !string.IsNullOrEmpty(outputDir);
        }
        /// <summary>
        /// The program for the manual is selected.
        /// </summary>
        /// <returns>Returns <c>true</c> if <see cref="program"/> is not null or empty, <c>false</c> otherwise.</returns>
        internal bool ProgramIsSelected()
        {
            return !string.IsNullOrEmpty(program);
        }
        /// <summary>
        /// <para>
        /// Checks the application is ready perform the manual XML splitting.<para>
        /// </para>If <see cref="XmlIsSelected"/> and <see cref="UowIsSelected"/> and <see cref="OutDirIsSelected"/> and <see cref="ProgramIsSelected"/>, <see cref="execButton"/> is enabled, otherwise it is disabled.
        /// </para>
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private void CheckExecuteSplitIsReady(object sender, EventArgs e)
        {
            execButton.SuspendLayout();
            if (XmlIsSelected() && UowIsSelected() && OutDirIsSelected() && ProgramIsSelected())
            {
                execButton.Enabled = true;
            }
            else
            {
                execButton.Enabled = false;
            }
            execButton.ResumeLayout();
        }
        /// <summary>
        /// Executes the split.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="EventArgs" /> instance containing the event data.</param>
        private async void ExecuteSplit(object sender, EventArgs e)
        {
            if (string.IsNullOrEmpty(uowTextBox.Text) && string.IsNullOrEmpty(uowContent))
            {
                XmlSplitterHelpers.ShowWarningBox("Please select a UOW states file before executing the split.", "Cannot proceed: No UOW states provided.");
                WriteLog("Prematurely attempted to begin splitting prior to specifying UOW states", Severity.Warning);
                return;
            }
            if (string.IsNullOrEmpty(program) && string.IsNullOrEmpty(programsComboBox.Text))
            {
                XmlSplitterHelpers.ShowWarningBox("Please select a program before executing the split.", "Cannot proceed: No program specified.");
                WriteLog("Prematurely attempted to begin splitting prior to specifying program", Severity.Warning);
                return;
            }
            if (xmlSourceFile is null && string.IsNullOrEmpty(xmlContent))
            {
                XmlSplitterHelpers.ShowWarningBox("Please select an XML file before executing the split.", "Cannot proceed: No XML file provided.");
                WriteLog("Prematurely attempted to begin splitting prior to specifying XML file", Severity.Warning);
                return;
            }
            if (string.IsNullOrEmpty(outputDir))
            {
                XmlSplitterHelpers.ShowWarningBox("Please select an output directory before executing the split.", "Cannot proceed: No output directory provided.");
                WriteLog("Prematurely attempted to begin splitting prior to specifying output directory", Severity.Warning);
                return;
            }
            // check if outputDir exists, if not, create it
            if (!Directory.Exists(outputDir))
            {
                try
                {
                    _ = Directory.CreateDirectory(outputDir);
                }
                catch (Exception ex)
                {
                    XmlSplitterHelpers.ShowWarningBox("Unable to create output directory '{outputDir}': {ex.Message}", "Cannot proceed: Unable to create output directory.");
                    WriteLog($"Unable to create output directory '{outputDir}': {ex.Message}", Severity.Fatal);
                    return;
                }
            }

            if (string.IsNullOrEmpty(xmlContent) || string.IsNullOrEmpty(xmlSourceFile)) return;
            execButton.Visible = false;
            // show the progress bar
            using ProgressBar progressBar = new();
            progressBar.Location = execButton.Location;
            progressBar.Size = execButton.Size;
            progressBar.Dock = execButton.Dock;
            progressBar.Anchor = execButton.Anchor;
            progressBar.TabIndex = execButton.TabIndex;
            progressBar.TabStop = execButton.TabStop;
            progressBar.Enabled = true;
            progressBar.Visible = true;
            progressBar.Minimum = 0;
            progressBar.Maximum = 100;
            progressBar.Value = 0;
            stepsPanel.Controls.Add(progressBar);

            try
            {


                await Task.Run(() => xml.LoadXml(xmlContent)).ConfigureAwait(true);

                if (string.IsNullOrEmpty(xpath))
                {
                    var logMessages = await Task.Run(() => ProcessUowStates(sender, e)).ConfigureAwait(true);
                    foreach (var logMessage in logMessages)
                    {
                        WriteLog(logMessage.Message, logMessage.Severity);
                        if (logMessage.Severity > Severity.Hint)
                        {
                            XmlSplitterHelpers.ShowWarningBox(logMessage.Message, Enum.GetName(logMessage.Severity));
                        }
                    }
                }
                if (string.IsNullOrEmpty(xpath) || fullyQualifiedSelectedStates is null)
                {
                    WriteLog("Stopping split. No units of work selected.", Severity.Error);
                }
                else
                {
                    // the element names that are eligible for export
                    string[]? checkoutElementNames = null;
                    // the nodes that will be split off from the XML
                    XmlNode[]? nodes = null;
                    if (checkoutItems is not null && manualFromDocnbr is not null && xml.DocumentElement?.GetAttribute("docnbr") is { } docnbr && !string.IsNullOrEmpty(program))
                    {
                        WriteLog($"Using checkout element names on {Path.GetFileName(xmlSourceFile)} to restrict XPath query by docnbr '{docnbr}'.");
                        var ofPrograms = Enum.Parse<XmlSplitterHelpers.CsdbProgram>(program);
                        var manual = manualFromDocnbr[ofPrograms][docnbr];
                        foreach (var manualNameKey in checkoutItems[ofPrograms].Keys)
                        {
                            XmlSplitterHelpers.BestMatch.Enqueue(manualNameKey, XmlSplitterHelpers.Jaccard.Distance(manual, manualNameKey));
                        }

                        checkoutElementNames = checkoutItems[ofPrograms][XmlSplitterHelpers.BestMatch.Dequeue()];
                        nodes = await Task.Run(() => xml.SelectNodesByCheckout(xpath, checkoutElementNames)).ConfigureAwait(true);
                    }
                    else
                    {
                        WriteLog($"Not using checkout element names on {Path.GetFileName(xmlSourceFile)}. Using unmodified XPath query.");
                        if (await Task.Run(() => xml.SelectNodes(xpath)).ConfigureAwait(true) is { } nodeList)
                        {
                            nodes = nodeList.Cast<XmlNode>().ToArray();
                        }
                    }
                    if (nodes is not null && nodes.Length > 0)
                    {
                        WriteLog($"Splitting XML file '{Path.GetFileName(xmlSourceFile)}' into {nodes.Length} fragments");
                        report = [];
                        StringBuilder htmlReportBuilder = new();
                        _ = htmlReportBuilder.Append(CultureInfo.InvariantCulture, $"""
                             <!DOCTYPE html>
                             <html lang="en">
                             <head>
                                 <meta charset="UTF-8">
                                 <meta name="viewport" content="width=device-width, initial-scale=1.0">
                                 <title>Report on Splitting {XmlSourceFileBaseName}</title>
                                 <style>
                             """);
                        _ = htmlReportBuilder.Append("""
                                                         * {
                                                             font-family: Aptos, Aptos_EmbeddedFont, Aptos_MSFontService, Calibri, Helvetica, sans-serif;
                                                         }
                                                         code {
                                                             font-family: "Aptos Mono", Aptos_EmbeddedFont, Aptos_MSFontService, monospace;
                                                         }
                                                         table,
                                                         th,
                                                         td {
                                                             border: 1px solid black;
                                                             border-collapse: collapse;
                                                             width: auto;
                                                             text-wrap: pretty;
                                                             overflow-wrap: anywhere;
                                                         }
                                                         th,
                                                         td {
                                                             padding: 5px;
                                                             text-align: left;
                                                         }
                                                 
                                                         tr:nth-child(even) {
                                                             background-color: #eee;
                                                         }
                                                 
                                                         tr:nth-child(odd) {
                                                             background-color: #fff;
                                                         }
                                                         aside {
                                                             background-color: #e7f3fe;
                                                             border-left: 6px solid #2196F3;
                                                             text-align: left;
                                                             padding: 4px;
                                                             -webkit-box-shadow: 2px 2px 4px -1px rgba(0, 0, 0, 0.75);
                                                             -moz-box-shadow: 2px 2px 4px -1px rgba(0, 0, 0, 0.75);
                                                             box-shadow: 2px 2px 4px -1px rgba(0, 0, 0, 0.75);
                                                             margin-bottom: 0.5em;
                                                         }
                                                         aside::before {
                                                             content: "ⓘ";
                                                             font-weight: bold;
                                                             font-size: 1.5em;
                                                             display: inline-block;
                                                             line-height: 0.9em;
                                                             color: #2196F3;
                                                             text-shadow: 1px 1px 4px black;
                                                             background-color: white;
                                                             border-radius: 50%;
                                                             margin-right: 0.4em;
                                                         }
                                                         pre {
                                                             display: block;
                                                             background: black;
                                                             color: aliceblue;
                                                             padding: 0.75em;
                                                             min-height: 4vh;
                                                         }
                                                     </style>
                                                 </head>
                                                 """);
                        var dateTimeNow = DateTime.Now.ToString(XmlSplitterHelpers.ReportTimestampFormat, CultureInfo.InvariantCulture);
                        var reportBaseFilename = $"{XmlSourceFileBaseName}SplittingReport - {dateTimeNow}";
                        var splittingReportFilenames = Enum.GetNames<XmlSplitReport.ReportFormat>().Select(format => $"{reportBaseFilename}.{format.ToLowerInvariant()}").ToArray();
                        _ = htmlReportBuilder.Append(CultureInfo.InvariantCulture, $"""
                             <body>
                                 <p>The source XML, '{Path.GetFileName(xmlSourceFile)}', was split into {nodes.Length} unit of work nodes.</p>
                                 <p>The complete splitting report is written as {string.Join(", ", Enum.GetNames<XmlSplitReport.ReportFormat>())} in the WIP package with the following file names:</p>
                                 <ul>
                                     {string.Join(Environment.NewLine, splittingReportFilenames.Select(filename => $"<li><see href=\"{new Uri(Path.Combine(outputDir, filename)).AbsoluteUri}\">{filename}</a></li>").ToArray())}
                                 </ul>
                                 <p>Below is the full HTML report of the XML splitting results:</p>
                                 <table>
                                     <caption><p>Table showing the details on each node that was split from the source XML.</p><aside aria-label="Information note">The tag of the parent is the <em>most recent containing XML node</em> having a <code>key</code> attribute; or, where there is no such <code>key</code>-bearing node, the root node for the document is indicated. For brevity, the parent tag is represented as a self-closing tag without inner XML.</aside><aside aria-label="Information note">"Node" in this context refers to the unit of work as an <see href="https://learn.microsoft.com/en-us/dotnet/api/system.xml.xmlnode?view=net-8.0"><code>XmlNode</code></a> that was split off from the source <see href="https://learn.microsoft.com/en-us/dotnet/api/system.xml.xmldocument?view=net-8.0"><code>XmlDocument</code></a>.</aside></caption>
                                     <colgroup><col /><col /><col /><col /><col /><col /><col /><col /><col /><col /><col /><col /><col /></colgroup>
                                     <tr>
                                         <th>Checkout Parent Number</th>
                                         <th>Checkout Parent Element's Name</th>
                                         <th>Checkout Parent's 'Key' Value</th>
                                         <th>Checkout Parent's Opening Tag</th>
                                         <th>UOW Node Number</th>
                                         <th>UOW Node Element's Name</th>
                                         <th>UOW Node's 'Key' Value</th>
                                         <th>Key-bearing Parent's Opening Tag</th>
                                         <th>Full XPath to UOW Node</th>
                                         <th>Filename of Split</th>
                                         <th>UOW State Value</th>
                                         <th>UOW State Name</th>
                                         <th>UOW State Remark</th>
                                     </tr>
                             """);
                        if (fullyQualifiedSelectedStates.ToArray() is not { } sourceStates) return;
                        Dictionary<XmlNode, List<(UowState, XmlNode)>> childrenPerCheckoutItem = new(nodes.Length);
                        for (var i = 0; i < sourceStates.Length; i++)
                        {
                            progressBar.Value = 100 * (i + 1) / sourceStates.Length;
                            var foundParent = false;
                            if (sourceStates[i] is { XPath: { } curXPath } curState && xml.SelectSingleNode(curXPath) is { } curNode)
                            {
                                // find the node in nodes that is the parent of curNode
                                foreach (var node in nodes)
                                {
                                    if (!XmlSplitterHelpers.IsDescendant(node, curNode)) continue;
                                    foundParent = true;
                                    // append curNode to childrenPerCheckoutItem[node]
                                    if (childrenPerCheckoutItem.TryGetValue(node, out var value))
                                    {
                                        value.Add((curState, curNode));
                                    }
                                    else
                                    {
                                        childrenPerCheckoutItem.Add(node, [(curState, curNode)]);
                                    }
                                    break;
                                }
                            }
                            if (!foundParent && checkoutElementNames is not null && $"({string.Join('|', checkoutElementNames)})" is { } checkoutElementsRe && Regex.IsMatch(sourceStates[i].TagName ?? string.Empty, checkoutElementsRe, RegexOptions.IgnoreCase))
                            {
                                Debug.WriteLine($"Could not find the parent node for state {sourceStates[i]}", "Error");
                            }
                        }
                        var nodeNum = 1;
                        List<string> additionalMessages = [];
                        for (var i = 0; i < nodes.Length; i++)
                        {
                            BaXmlDocument xmlFragment = new()
                            {
                                ResolveEntities = false
                            };
                            _ = await Task.Run(() => xmlFragment.AppendChild(xmlFragment.ImportNode(nodes[i], true))).ConfigureAwait(true);
                            if (nodes[i].Attributes?["key"]?.Value is { } key)
                            {
                                var outPath = Path.Combine(outputDir, $"{XmlSourceFileBaseName}-{key}.xml");
                                // write the fragment to the outPath
                                await Task.Run(() => xmlFragment.Save(outPath)).ConfigureAwait(true);
                                WriteLog($"Wrote fragment to '{outPath}'");
                                if (!childrenPerCheckoutItem.TryGetValue(nodes[i], out var children))
                                {
                                    continue;
                                }
                                // create an entry per child on childrenPerCheckoutItem
                                var numChildren = children.Count;
                                for (var j = 0; j < numChildren; j++)
                                {
                                    var (curState, curNode) = childrenPerCheckoutItem[nodes[i]][j];
                                    var parentTag = XmlSplitterHelpers.CalculateParentTag(curNode);
                                    XmlSplitReportEntry reportEntry = new(checkoutParent: nodes[i], checkoutParentNumber: i + 1, nodeNumber: nodeNum++, uowNode: curNode, keyedParentTag: parentTag, fullXPath: GenerateUniqueXPath(curNode), filenameOfSplit: Path.GetFileName(outPath), uowState: curState);
                                    report.Add(reportEntry);
                                    _ = htmlReportBuilder.Append("<tr>");
                                    if (j == 0)
                                    {
                                        _ = htmlReportBuilder.Append(CultureInfo.InvariantCulture, $"""
                                                 <!-- Checkout Parent Number --><td rowspan='{numChildren}'>{reportEntry.CheckoutParentNumber}</td>
                                                 <!-- Checkout Parent Name --><td rowspan='{numChildren}'>{reportEntry.CheckoutParent.Name}</td>
                                                 <!-- Checkout's 'Key' Value --><td rowspan='{numChildren}'>{reportEntry.CheckoutParent.Attributes?["key"]?.Value ?? "&nbsp;"}</td>
                                                 <!-- Checkout Parent Tag --><td rowspan='{numChildren}'><code>{HttpUtility.HtmlEncode(reportEntry.CheckoutParent.OuterXml)}</code></td>
                                             """);
                                    }
                                    _ = htmlReportBuilder.Append(CultureInfo.InvariantCulture, $"""
                                             <!-- Node Number --><td>{reportEntry.NodeNumber}</td>
                                             <!-- Node Element Name --><td>{reportEntry.UowNode.Name}</td>
                                             <!-- Node's 'Key' Value --><td>{(curNode.Attributes?["key"]?.Value ?? "&nbsp;")}</td>
                                             <!-- Key-bearing Parent's Tag --><td><code>{HttpUtility.HtmlEncode(reportEntry.KeyedParent.OuterXml)}</code></td>
                                             <!-- Full XPath --><td><code>{HttpUtility.HtmlEncode(reportEntry.FullXPath)}</code></td>
                                             <!-- Filename of Split --><td>{reportEntry.FilenameOfSplit}</td>
                                             <!-- ETPS UOW State Value --><td>{reportEntry.UowState.StateValue}</td>
                                             <!-- ETPS UOW State Name --><td>{reportEntry.UowState.StateName}</td>
                                             <!-- ETPS UOW State Remark --><td>{(string.IsNullOrEmpty(reportEntry.UowState.Remark) ? "&nbsp;" : HttpUtility.HtmlEncode(reportEntry.UowState.Remark))}</td>
                                         </tr>
                                         """);
                                    var keyedParentIsCheckoutParent = reportEntry.KeyedParent.OuterXml == reportEntry.CheckoutParent.OuterXml;
                                    var keyedParentIsUowNode = reportEntry.KeyedParent.Attributes?["key"]?.Value is not null && reportEntry.KeyedParent.Attributes?["key"]?.Value == reportEntry.UowNode.Attributes?["key"]?.Value && reportEntry.KeyedParent.Name == reportEntry.UowNode.Name;
                                    if (keyedParentIsCheckoutParent && keyedParentIsUowNode)
                                    {
                                        additionalMessages.Add($"Notice that the incremental revision unit-of-work node {reportEntry.NodeNumber} is a checkout node with a unique key ({reportEntry.UowNode.Attributes?["key"]?.Value}). This is why there is repetition of the key and tag values.");
                                    }
                                    else if (keyedParentIsCheckoutParent)
                                    {
                                        additionalMessages.Add($"Notice that the key-bearing parent on the unit-of-work node {reportEntry.NodeNumber} is also the checkout node. This is why the tag values (\"Checkout Parent's Opening Tag\" and \"Key-bearing Parent's Opening Tag\") are repeated.");
                                    }
                                    else if (keyedParentIsUowNode)
                                    {
                                        additionalMessages.Add($"Notice that the incremental revision unit-of-work node {reportEntry.NodeNumber} has a unique key ({reportEntry.UowNode.Attributes?["key"]?.Value}) the same as its parent. This is why there is repetition of the key value.");
                                    }
                                }
                            }
                            else
                            {
                                WriteLog($"Unable to get 'key' attribute from node #{nodeNum} ({nodes[i].Name}) on UOW #{i + 1}. Skipping.", Severity.Warning);
                            }
                        }
                        _ = htmlReportBuilder.Append(CultureInfo.InvariantCulture, $"</table><p>{string.Join(' ', additionalMessages)}</p></body></html>");
                        splittingReportHtml = htmlReportBuilder.ToString();
                        WriteLog("Done splitting XML file. Showing results report.");
                        await Task.Run(() => GenerateOtherReports(reportBaseFilename)).ConfigureAwait(true);
                        // display the report in the default browser
                        await Task.Run(DisplayHtmlReport).ConfigureAwait(false);
                    }

                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex);
                WriteLog(ex.Message, Severity.Fatal);
            }
            finally
            {
                progressBar.Visible = false;
                stepsPanel.Controls.Remove(progressBar);
                execButton.Visible = true;
            }

        }

        /// <summary>
        /// Generates the XML, CSV, TSV reports.
        /// </summary>
        /// <param name="baseFilename">The base filename.</param>
        /// <returns></returns>
        private void GenerateOtherReports(string baseFilename)
        {
            if (report is null || string.IsNullOrEmpty(outputDir)) return;
            foreach (XmlSplitReport.ReportFormat format in Enum.GetValuesAsUnderlyingType<XmlSplitReport.ReportFormat>())
            {
                var reportFilename = Path.Combine(outputDir, $"{baseFilename}.{Enum.GetName(format)}");
                WriteLog($"Writing report to {reportFilename}");
                report.Save(reportFilename, format);
            }
        }

        /// <summary>
        /// Displays the HTML report.
        /// </summary>
        /// <returns></returns>
        private void DisplayHtmlReport()
        {
            if (string.IsNullOrEmpty(splittingReportHtml) || string.IsNullOrEmpty(xmlSourceFile))
            {
                WriteLog("No HTML report to display.", Severity.Warning);
                return;
            }
            var reportOutPath = Path.Combine(outDirTextBox.Text, $"Splitting{XmlSourceFileBaseName}Report-{DateTime.Now:yyyy-MM-dd-HH-mm-ss-fffffff}.html");
            WriteLog("Displaying HTML report using default browser.");
            try
            {
                File.WriteAllText(reportOutPath, splittingReportHtml);
                ProcessStartInfo psi = new()
                {
                    UseShellExecute = true,
                    FileName = reportOutPath
                };
                Process.Start(psi);
            }
            catch (Exception ex)
            {
                WriteLog(ex.ToString(), Severity.Error);
                return;
            }
            WriteLog($"Wrote XML splitting report to {reportOutPath}");
        }

        /// <summary>
        /// Generates the unique XPath for the XML node.
        /// </summary>
        /// <param name="xmlNode">The XML node.</param>
        /// <returns>An XPath for the given node.</returns>
        private static string GenerateUniqueXPath(XmlNode xmlNode)
        {
            if (xmlNode.NodeType == XmlNodeType.Attribute && xmlNode is XmlAttribute { OwnerElement: not null } xmlNodeAsAttribute)
            {
                // attributes have an OwnerElement, not a ParentNode; also they have             
                // to be matched by name, not found by position
                return $"{GenerateUniqueXPath(xmlNodeAsAttribute.OwnerElement)}/@{xmlNode.Name}";
            }
            if (xmlNode.ParentNode is null)
            {
                // the only node with no parent is the root node, which has no path
                return string.Empty;
            }

            // Get the Index
            var indexInParent = 1;
            var siblingNode = xmlNode.PreviousSibling;
            // Loop thru all Siblings
            while (siblingNode is not null)
            {
                // Increase the Index if the Sibling has the same Name
                if (siblingNode.Name == xmlNode.Name)
                {
                    indexInParent++;
                }
                siblingNode = siblingNode.PreviousSibling;
            }

            // the path to a node is the path to its parent, plus "/node()[n]", where n is its position among its siblings.         
            return $"{GenerateUniqueXPath(xmlNode.ParentNode)}/{xmlNode.Name}[{indexInParent}]";
        }

        /// <summary>
        /// Called when [drag drop].
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="DragEventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private void OnDragDrop(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Copy;
            var data = e.Data;
            if (data?.GetData(DataFormats.FileDrop) is null) return;
            if (data.GetData(DataFormats.FileDrop) is not string[] paths) return;
            foreach (var path in paths.Distinct())
            {
                if (File.Exists(path))
                {
                    if (Path.GetExtension(path).Equals(".xml", StringComparison.OrdinalIgnoreCase))
                    {

                        xmlSelectTextBox.Text = path;
                        XmlSelectTextBox_TextChanged(sender, e);
                    }
                    else
                    {
                        if (XmlSplitterHelpers.IsBinary(path) && !XmlSplitterHelpers.ShowConfirmationBox($"The file at '{path}' appears to be a binary file, not text. Continue?",
                                $"{Path.GetFileName(path)} appears to be binary"))
                        {
                            continue;
                        }
                        uowSelectBox.Text = path;
                        UowStatesTextBox_TextChanged(sender, e);
                    }
                }
                else if (Directory.Exists(path))
                {
                    outDirTextBox.Text = path;
                    OutDirTextBox_TextChanged(sender, e);
                }
            }
        }

        /// <summary>
        /// Processes the unit-of-work states file.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private LogMessage[] ProcessUowStates(object sender, EventArgs e)
        {
            List<LogMessage> logMessages =
            [
                new LogMessage("Parsing units of work states file")
            ];
            var states = XmlSplitterHelpers.ParseUowContent(uowContent, program, statesPerProgram, uowStatesFile, out _, out var statesInManual, out var impliedDocnbr);
            if (states is null)
            {
                logMessages.Add(new LogMessage("Not ready to process unit of work states. Check that UOW states file was loaded and parsed properly.", Severity.Warning));
            }
            else
            {
                // check that the root node name is the same as the uowStatesFileDocnbr
                if (xml.DocumentElement is null || string.IsNullOrEmpty(xml.DocumentElement.GetAttribute("docnbr")))
                {
                    logMessages.Add(new LogMessage("No docnbr identifiable in root node's XML content. Please check the XML is correct.", Severity.Error));
                    return [.. logMessages];
                }

                if (string.IsNullOrEmpty(impliedDocnbr))
                {
                    logMessages.Add(new LogMessage("The UOW states file was empty. Please check the UOW states file is correct.", Severity.Error));
                    return [.. logMessages];
                }

                if (!xml.DocumentElement.GetAttribute("docnbr").Equals(impliedDocnbr, StringComparison.OrdinalIgnoreCase))
                {
                    logMessages.Add(new LogMessage(string.Format("Root node docnbr '{0}' does not match UOW states file docnbr '{1}'. Please check the UOW states file is correct.", xml.DocumentElement.GetAttribute("docnbr").ToUpperInvariant(), impliedDocnbr.ToUpperInvariant()), Severity.Error));
                    return [.. logMessages];
                }
                logMessages.Add(new LogMessage(string.Format("Found {0} distinct work states in the manual:\n\t{1}", statesInManual.Count, string.Join("\n\t", statesInManual.Values.Cast<UowState>().Select(uow => uow.ToString())))));
                var items = statesInManual.Values.Cast<UowState>().ToArray().Select(state => new ListViewItem(new[] { state.StateValue.ToString() ?? "", state.StateName ?? "", state.Remark ?? "" }));
                // display the multi select list view
                SelectStates dialog = new(items.ToArray(), states)
                {
                    Font = Font,
                    StartPosition = FormStartPosition.CenterParent,
                    Icon = Properties.Resources.Icon
                };
                _ = dialog.ShowDialog();
                if (dialog.DialogResult != DialogResult.OK) return [.. logMessages];
                var selectedStates = dialog.SelectedStates;
                if (selectedStates is not null && selectedStates.Length > 0)
                {
                    fullyQualifiedSelectedStates = states.Where(state =>
                        selectedStates.Select(uowState => uowState.StateValue).Contains(state.StateValue));
                    xpath = string.Join('|', fullyQualifiedSelectedStates.Select(state => state.XPath));
                    XPathTextBox_TextChanged(sender, e);
                }
                else
                {
                    logMessages.Add(new LogMessage("No states chosen to split manual.", Severity.Warning));
                }
            }
            return [.. logMessages];
        }


        /// <summary>
        /// CsdbProgram the group box handler.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private void ProgramGroupBox(object sender, EventArgs e)
        {
            if ((string.IsNullOrEmpty(program) && !string.IsNullOrEmpty(programsComboBox.Text)) || (program != programsComboBox.Text && XmlSplitterHelpers.Programs.Contains(programsComboBox.Text)))
            {
                program = programsComboBox.Text;
                WriteLog($"program chosen for manual: {program}");
            }
            CheckExecuteSplitIsReady(sender, e);
        }

        private void MouseEnteredExecButton(object sender, EventArgs e)
        {
            if (!execButton.Enabled)
            {
                string toolTipText = new("Before executing the split");
                toolTip.ToolTipTitle = "Not ready";
                if (!XmlIsSelected())
                {
                    toolTipText += ", Select XML file";
                }
                if (!UowIsSelected())
                {
                    toolTipText += ", Select UOW states file";
                }
                if (!OutDirIsSelected())
                {
                    toolTipText += ", Select an output directory";
                }
                if (!ProgramIsSelected())
                {
                    toolTipText += ", Select a program";
                }
                toolTip.SetToolTip(stepsPanel, toolTipText);
            }
            else
            {
                toolTip.ToolTipIcon = ToolTipIcon.None;
                toolTip.ToolTipTitle = "Ready";
                toolTip.SetToolTip(execButton, "Execute split");
            }
        }
        /// <summary>
        /// Mouse has left the execute button region.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private void MouseLeftExecButton(object sender, EventArgs e)
        {
            toolTip.Hide(stepsPanel);
        }

        private void OptionsToolStripMenuItem_Click(object sender, EventArgs e)
        {
            // show the settings page
            using var settingsPage = new SettingsPage();
            settingsPage.ShowDialog();
        }

        [GeneratedRegex("[_-]$")]
        private static partial Regex TerminusChars();
    }
}
