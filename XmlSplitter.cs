using BaXmlSplitter.Properties;
using System.Collections;
using System.Diagnostics;
using System.Drawing.Text;
using System.Text;
using System.Text.RegularExpressions;
using System.Web;
using System.Xml;


namespace BaXmlSplitter
{
    /// <summary>
    ///  The main form for the XML splitting tool.
    ///  TODO: Allow full automation.
    /// </summary>
    /// <seealso cref="Form" />
    public partial class XmlSplitter : Form
    {
        [System.Runtime.InteropServices.LibraryImport("gdi32.dll")]
        internal static partial IntPtr AddFontMemResourceEx(IntPtr pbFont, uint cbFont,
            IntPtr pdv, in uint pcFonts);

        /// <summary>The font collection
        /// for the splitter user-interface.</summary>
        private PrivateFontCollection fonts = new();
        /// <summary>The log file path
        /// for the XML splitting.</summary>
        private string logFile;
        /// <summary>The HTML splitting report
        /// that is generated by the tool after the splitting operation is completed.</summary>
        private string? splittingReportHtml;
        /// <summary>The report object that is used to keep a record of all the nodes that were split off from the XML. 
        /// Nodes are recorded as <see cref="XmlSplitReportEntry" /> objects.</summary>
        /// <seealso cref="XmlSplitReportEntry" />
        private XmlSplitReport? report;
        /// <summary>
        /// The path to the source XML file on which the split will be performed.
        /// </summary>
        private string? xmlSourceFile;
        private string? XmlSourceFileBaseName { get => XmlSplitterHelpers.XML_FILENAME_RE.Replace(Path.GetFileNameWithoutExtension(xmlSourceFile ?? string.Empty), m => Regex.Replace(m.Groups[1].Value, @"[_-]$", string.Empty)); }
        /// <summary>The string content of the XML file on which the split will be performed. This is 
        /// loaded into memory as soon as the XML is selected.</summary>
        private string? xmlContent;
        /// <summary>The XML object that will parse the XML content. </summary><seealso cref="BaXmlDocument" />
        private BaXmlDocument xml = new()
        {
            ResolveEntities = false
        };
        /// <summary>The path to the file that contains the work states for the units of work (UOW) in the XML.</summary>
        private string? uowStatesFile;
        /// <summary>
        /// The content of the UOW states file. This is loaded into memory as soon as the UOW states file is selected.
        /// </summary>
        private string? uowContent;
        /// <summary>
        /// The directory to which the split XML files will be written. <see cref="XmlSplitterHelpers.DEFAULT_OUTPUT_DIR">By default</a>, this will be the <c>"WIP"</c> directory in the same directory as the source XML file.
        /// </summary>
        private string? outputDir;
        /// <summary>
        /// The XPath string that would be used to select the nodes to split from the XML. This is calculated from the tag names and key values in the UOW states file.
        /// </summary>
        private string? xpath;
        /// <summary>A dictionary of all the states in any CSDB program (GXPROD, CTALPROD, B_IFM, CH604PROD, LJ4045PROD).</summary>
        private Dictionary<XmlSplitterHelpers.Programs, Dictionary<int, UowState>>? statesPerProgram;
        /// <summary>The CSDB element names eligible for importing to RWS Contenta.</summary>
        private Dictionary<XmlSplitterHelpers.Programs, Dictionary<string, string[]>>? checkoutItems;
        /// <summary>The lookup table for manual type from docnbr.</summary>
        private Dictionary<XmlSplitterHelpers.Programs, Dictionary<string, string>>? manualFromDocnbr;
        /// <summary>The CSDB program (GXPROD, CTALPROD, B_IFM, CH604PROD, LJ4045PROD)
        /// for the manual.</summary>
        private string? program;
        /// <summary>The fully populated unit-of-work states that are selected by the user for export.</summary>
        private IEnumerable<UowState>? fullyQualifiedSelectedStates;

        /// <summary>
        /// Loads the fonts.
        /// </summary>
        /// <returns></returns>
        private void LoadFonts()
        {
            uint discard = 0;
            byte[][] seventyTwoFonts =
            [
                Resources._72_Black,
                Resources._72_Bold,
                Resources._72_BoldItalic,
                Resources._72_Condensed,
                Resources._72_CondensedBold,
                Resources._72_Italic,
                Resources._72_Light,
                Resources._72_Monospace_Bd,
                Resources._72_Monospace_Rg,
                Resources._72_Regular
            ];
            for (int i = 0; i < seventyTwoFonts.Length; i++)
            {
                IntPtr data = System.Runtime.InteropServices.Marshal.AllocCoTaskMem(seventyTwoFonts[i].Length);
                try
                {
                    System.Runtime.InteropServices.Marshal.Copy(seventyTwoFonts[i], 0, data, seventyTwoFonts[i].Length);
                    _ = AddFontMemResourceEx(data, (uint)seventyTwoFonts[i].Length, IntPtr.Zero, in discard);
                    fonts.AddMemoryFont(data, seventyTwoFonts[i].Length);
                }
                finally
                {
                    System.Runtime.InteropServices.Marshal.FreeCoTaskMem(data);
                }
            }
        }
        /// <summary>
        /// Initializes a new instance of the <see cref="XmlSplitter"/> class.
        /// </summary>
        public XmlSplitter()
        {
            InitializeComponent();
            logFile = Path.Combine(Path.GetTempPath(), string.Format("BaXmlSplitter-{0}.log", DateTime.Now.ToString("yyyy-MM-dd-HH-mm-ss-fffffff")));
            File.Move(Path.GetTempFileName(), logFile);
            logTextBox.SuspendLayout();
            logTextBox.Font = new Font("Cascadia Mono", 10);
            logTextBox.SelectAll();
            logTextBox.SelectionIndent += 10;
            logTextBox.SelectionRightIndent += 10;
            logTextBox.DeselectAll();
            logTextBox.ResumeLayout();
            programsComboBox.SuspendLayout();
            programsComboBox.AutoCompleteCustomSource.AddRange(Enum.GetNames<XmlSplitterHelpers.Programs>());
            programsComboBox.Items.AddRange(Enum.GetNames<XmlSplitterHelpers.Programs>());
            programsComboBox.ResumeLayout();
            WriteLog($"Started XML splitting tool with real time log at '{logFile}'");
        }

        /// <summary>
        /// Handles the Load event of the XmlSplitter control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private async void XmlSplitter_Load(object sender, EventArgs e)
        {
            CheckExecuteSplitIsReady(sender, e);  // just disable execButton on load
            await Task.Run(() =>
            {
                LoadFonts();
                statesPerProgram = XmlSplitterHelpers.DeserializeStates();
                checkoutItems = XmlSplitterHelpers.DeserializeCheckoutItems();
                manualFromDocnbr = XmlSplitterHelpers.DeserializeDocnbrManualFromProgram();
            });
            WriteLog("Finished initializing.");
        }

        /// <summary>
        /// Writes the log.
        /// </summary>
        /// <param name="message">The message.</param>
        /// <param name="severity">The severity.</param>
        /// <param name="NoNewLine">if set to <c>true</c> [no new line].</param>
        /// <param name="SkipFile">if set to <c>true</c> [skip file].</param>
        /// <returns></returns>
        private void WriteLog(string message, Severity severity = Severity.Hint, bool NoNewLine = false, bool SkipFile = false)
        {

            void logDelegate()
            {
                string timestamped = string.Format("{0}:\t{1}", DateTime.Now.ToString(XmlSplitterHelpers.TIMESTAMP_FORMAT), message + (NoNewLine ? "" : Environment.NewLine));
                if (!SkipFile)
                {
                    try
                    {
                        using FileStream log = File.Open(logFile, FileMode.Append);
                        try
                        {

                            using StreamWriter logWriter = new(log);
                            try
                            {
                                logWriter.Write(timestamped);
                                logWriter.Flush();
                            }
                            finally
                            {
                                logWriter.Close();
                                logWriter.Dispose();
                            }
                        }
                        finally
                        {
                            log.Close();
                            log.Dispose();
                        }
                    }
                    catch (Exception e)
                    {
                        WriteLog($"Unable to write to log file at {logFile}: {e.Message}", Severity.Error, false, true);
                    }
                }
                logTextBox.SuspendLayout();
                switch (severity)
                {
                    case Severity.Hint:
                        logTextBox.SelectionColor = Color.Lime;
                        break;
                    case Severity.Warning:
                        logTextBox.SelectionColor = Color.Gold;
                        break;
                    case Severity.Error:
                        logTextBox.SelectionColor = Color.OrangeRed;
                        break;
                    case Severity.Fatal:
                        logTextBox.SelectionColor = Color.Red;
                        break;
                }
                logTextBox.AppendText(timestamped);
                logTextBox.ScrollToCaret();
                logTextBox.ResumeLayout();
            }
            if (logTextBox.InvokeRequired)
            {
                logTextBox.Invoke(logDelegate);
            }
            else
            {
                logDelegate();
            }
        }

        /// <summary>
        /// Browses for the XML to split.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="EventArgs" /> instance containing the event data.</param>
        /// <returns></returns>
        private void BrowseXml(object sender, EventArgs e)
        {
            string filename = XmlSplitterHelpers.BrowseForFile(filter: "Flight or maintenance manual|*.xml", startingPath: xmlSelectTextBox.Text);
            xmlSelectTextBox.Text = filename;
            XmlSelectTextBox_TextChanged(sender, e);
        }

        /// <summary>
        /// Browses for the current states file.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private void BrowseUow(object sender, EventArgs e)
        {
            string filename = XmlSplitterHelpers.BrowseForFile(filter: "UOW states file|*.*", startingPath: uowTextBox.Text);
            while (Path.GetExtension(filename).Equals(".xml", StringComparison.OrdinalIgnoreCase) && !XmlSplitterHelpers.ShowConfirmationBox($"The chosen UOW states file {Path.GetFileName(filename)} appears to be an XML file, not a file generated by the $LAUNCH tool in Unix. Proceed anyway?", "XML chosen as UOW states file"))
            {
                filename = XmlSplitterHelpers.BrowseForFile(filter: "UOW states file|*.*", startingPath: uowTextBox.Text);
            }
            uowTextBox.Text = filename;
            UowStatesTextBox_TextChanged(sender, e);
        }

        /// <summary>
        /// Browses for output directory.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private void BrowseOutDir(object sender, EventArgs e)
        {
            using FolderBrowserDialog dialog = new();
            if (dialog.ShowDialog() == DialogResult.OK)
            {
                outDirTextBox.Text = dialog.SelectedPath;
                OutDirTextBox_TextChanged(sender, e);
            }
        }

        /// <summary>
        /// Handles the TextChanged event of the XPathTextBox control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private void XPathTextBox_TextChanged(object sender, EventArgs e)
        {
            void xpathTextBoxDelegate()
            {
                xpathTextBox.SuspendLayout();
                xpathLabel.SuspendLayout();
                xpathGroupBox.SuspendLayout();
                if (!string.IsNullOrEmpty(xpath) && (!xpathTextBox.Visible || !xpathGroupBox.Visible || !xpathLabel.Visible))
                {
                    xpathTextBox.Text = xpath;
                    xpathTextBox.Visible = true;
                    xpathGroupBox.Visible = true;
                    xpathLabel.Visible = true;
                }
                else
                {
                    xpathTextBox.Visible = false;
                    xpathGroupBox.Visible = false;
                    xpathLabel.Visible = false;
                }
                xpathGroupBox.ResumeLayout();
                xpathLabel.ResumeLayout();
                xpathTextBox.ResumeLayout();
            }
            if (xpathTextBox.InvokeRequired)
            {
                xpathTextBox.Invoke(xpathTextBoxDelegate);
            }
            else
            {
                xpathTextBoxDelegate();
            }
        }
        /// <summary>
        /// Handles the TextChanged event of the XmlSelectTextBox control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private async void XmlSelectTextBox_TextChanged(object sender, EventArgs e)
        {
            xmlSelectTextBox.Select(xmlSelectTextBox.Text.Length, 0);
            try
            {
                if (File.Exists(xmlSelectTextBox.Text))
                {
                    if (!string.IsNullOrEmpty(xmlSourceFile) && Path.GetFullPath(xmlSourceFile) == Path.GetFullPath(xmlSelectTextBox.Text))
                    {
                        return;
                    }
                    else
                    {
                        xmlSourceFile = Path.GetFullPath(xmlSelectTextBox.Text);
                    }
                    string? container = Path.GetDirectoryName(xmlSourceFile);
                    if (container is not null)
                    {
                        outDirTextBox.Text = Path.Combine(container, XmlSplitterHelpers.DEFAULT_OUTPUT_DIR);
                        OutDirTextBox_TextChanged(sender, e);
                    }
                    WriteLog(string.Format("Reading XML file '{0}'", Path.GetFileName(xmlSourceFile)));
                    //TextFileChosen(out xmlContent, xmlSelectTextBox.Text, xmlSelectTextBox, "XML");
                    xmlContent = await File.ReadAllTextAsync(xmlSourceFile);
                    if (string.IsNullOrEmpty(xmlContent) && new FileInfo(xmlSourceFile).Length > 0)
                    {
                        WriteLog("Unable to read XML file. Please check that the file is available and not locked by another process.", Severity.Error);
                    }
                    else
                    {
                        WriteLog("Done reading XML file into memory.");
                    }
                }
                else
                {
                    WriteLog("Please select a valid XML file.", Severity.Warning);
                }
            }
            catch (Exception exception)
            {
                WriteLog(exception.Message, Severity.Error);
            }
        }
        /// <summary>
        /// Handles the TextChanged event of the UowStatesTextBox control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private async void UowStatesTextBox_TextChanged(object sender, EventArgs e)
        {
            uowTextBox.Select(uowTextBox.Text.Length, 0);
            try
            {
                if (File.Exists(uowTextBox.Text) && (!XmlSplitterHelpers.IsBinary(uowTextBox.Text) || XmlSplitterHelpers.ShowConfirmationBox(string.Format("The file at '{0}' appears to be a binary file, not text. Continue?", uowTextBox.Text), string.Format("File '{0}' is not text", Path.GetFileName(uowTextBox.Text)))))
                {

                    if (!string.IsNullOrEmpty(uowStatesFile) && uowStatesFile == uowTextBox.Text)
                    {
                        return;
                    }
                    uowStatesFile = uowTextBox.Text;
                    WriteLog($"Reading UOW file '{Path.GetFileName(uowStatesFile)}'");
                    uowContent = await File.ReadAllTextAsync(uowStatesFile);
                    xpath = string.Empty;
                    XPathTextBox_TextChanged(sender, e);
                    if (string.IsNullOrEmpty(uowContent) && new FileInfo(uowStatesFile).Length > 0)
                    {
                        WriteLog("Unable to read UOW states file. Please check that the file is available and not locked by another process.", Severity.Error);
                    }
                    else
                    {
                        WriteLog("Done reading UOW file into memory.");
                    }
                }
                else
                {
                    WriteLog("Please provide a valid path", Severity.Warning);
                }
            }
            catch (Exception exception)
            {
                WriteLog(exception.Message, Severity.Error);
            }
        }

        /// <summary>
        /// Handles the TextChanged event of the OutDirTextBox control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private void OutDirTextBox_TextChanged(object sender, EventArgs e)
        {
            outDirTextBox.Select(outDirTextBox.Text.Length, 0);
            if (outputDir != outDirTextBox.Text)
            {
                // if the out dir does not exist, set outDirWillBeCreated.Visible to true
                try
                {
                    outputDir = outDirTextBox.Text;
                    outDirWillBeCreated.SuspendLayout();
                    if (!Directory.Exists(outputDir))
                    {
                        outDirWillBeCreated.Enabled = outDirWillBeCreated.Visible = true;
                        WriteLog("Output directory will be created.");
                    }
                    else
                    {
                        outDirWillBeCreated.Enabled = outDirWillBeCreated.Visible = false;
                    }
                    outDirWillBeCreated.ResumeLayout();
                    WriteLog($"Selected units of work will be written to {outputDir}");
                }
                catch (Exception exception)
                {
                    WriteLog(exception.Message, Severity.Error);
                }
            }
        }
        /// <summary>
        /// The XML is selected.
        /// </summary>
        /// <returns>Returns <c>true</c> if <see cref="xmlSourceFile" /> and <see cref="xmlContent" /> are both not null or empty, <c>false</c> otherwise.</returns>
        internal bool XmlIsSelected()
        {
            return !string.IsNullOrEmpty(xmlSourceFile) && !string.IsNullOrEmpty(xmlContent);
        }
        /// <summary>
        /// Units of work states for export are selected.
        /// </summary>
        /// <returns>Returns <c>true</c> if <see cref="uowStatesFile" /> and <see cref="uowContent" /> are both not null or empty, <c>false</c> otherwise.</returns>
        internal bool UowIsSelected()
        {
            return !string.IsNullOrEmpty(uowStatesFile) && !string.IsNullOrEmpty(uowContent);
        }
        /// <summary>
        /// Output directory is selected.
        /// </summary>
        /// <returns>Returns <c>true</c> if <see cref="outputDir"/> is not null or empty, <c>false</c> otherwise.</returns>
        internal bool OutDirIsSelected()
        {
            return !string.IsNullOrEmpty(outputDir);
        }
        /// <summary>
        /// The program for the manual is selected.
        /// </summary>
        /// <returns>Returns <c>true</c> if <see cref="program"/> is not null or empty, <c>false</c> otherwise.</returns>
        internal bool ProgramIsSelected()
        {
            return !string.IsNullOrEmpty(program);
        }
        /// <summary>
        /// <para>
        /// Checks the application is ready perform the manual XML splitting.<para>
        /// </para>If <see cref="XmlIsSelected"/> and <see cref="UowIsSelected"/> and <see cref="OutDirIsSelected"/> and <see cref="ProgramIsSelected"/>, <see cref="execButton"/> is enabled, otherwise it is disabled.
        /// </para>
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private void CheckExecuteSplitIsReady(object sender, EventArgs e)
        {
            execButton.SuspendLayout();
            if (XmlIsSelected() && UowIsSelected() && OutDirIsSelected() && ProgramIsSelected())
            {
                execButton.Enabled = true;
            }
            else
            {
                execButton.Enabled = false;
            }
            execButton.ResumeLayout();
        }
        /// <summary>
        /// Executes the split.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="EventArgs" /> instance containing the event data.</param>
        private async void ExecuteSplit(object sender, EventArgs e)
        {
            if (string.IsNullOrEmpty(uowTextBox.Text) && string.IsNullOrEmpty(uowContent))
            {
                XmlSplitterHelpers.ShowWarningBox("Please select a UOW states file before executing the split.", "Cannot proceed: No UOW states provided.");
                WriteLog("Prematurely attempted to begin splitting prior to specifying UOW states", Severity.Warning);
                return;
            }
            if (string.IsNullOrEmpty(program) && string.IsNullOrEmpty(programsComboBox.Text))
            {
                XmlSplitterHelpers.ShowWarningBox("Please select a program before executing the split.", "Cannot proceed: No program specified.");
                WriteLog("Prematurely attempted to begin splitting prior to specifying program", Severity.Warning);
                return;
            }
            if (xmlSourceFile is null && string.IsNullOrEmpty(xmlContent))
            {
                XmlSplitterHelpers.ShowWarningBox("Please select an XML file before executing the split.", "Cannot proceed: No XML file provided.");
                WriteLog("Prematurely attempted to begin splitting prior to specifying XML file", Severity.Warning);
                return;
            }
            if (string.IsNullOrEmpty(outputDir))
            {
                XmlSplitterHelpers.ShowWarningBox("Please select an output directory before executing the split.", "Cannot proceed: No output directory provided.");
                WriteLog("Prematurely attempted to begin splitting prior to specifying output directory", Severity.Warning);
                return;
            }
            // check if outputDir exists, if not, create it
            if (!Directory.Exists(outputDir))
            {
                try
                {
                    _ = Directory.CreateDirectory(outputDir);
                }
                catch (Exception ex)
                {
                    XmlSplitterHelpers.ShowWarningBox(string.Format("Unable to create output directory '{0}': {1}", outputDir, ex.Message), "Cannot proceed: Unable to create output directory.");
                    WriteLog(string.Format("Unable to create output directory '{0}': {1}", outputDir, ex.Message), Severity.Fatal);
                    return;
                }
            }
            if (!string.IsNullOrEmpty(xmlContent) && !string.IsNullOrEmpty(xmlSourceFile))
            {
                execButton.Visible = false;
                // show the progress bar
                using ProgressBar progressBar = new()
                {
                    Location = execButton.Location,
                    Size = execButton.Size,
                    Dock = execButton.Dock,
                    Anchor = execButton.Anchor,
                    TabIndex = execButton.TabIndex,
                    TabStop = execButton.TabStop,
                    Enabled = true,
                    Visible = true,
                    Minimum = 0,
                    Maximum = 100,
                    Value = 0
                };
                stepsPanel.Controls.Add(progressBar);

                await Task.Run(() => xml.LoadXml(xmlContent));

                if (string.IsNullOrEmpty(xpath))
                {
                    LogMessage[] logMessages = await Task.Run(() => ProcessUowStates(sender, e));
                    foreach (LogMessage logMessage in logMessages)
                    {
                        WriteLog(logMessage.Message, logMessage.Severity);
                        if (logMessage.Severity > Severity.Hint)
                        {
                            XmlSplitterHelpers.ShowWarningBox(logMessage.Message, Enum.GetName(logMessage.Severity));
                        }
                    }
                }
                if (string.IsNullOrEmpty(xpath) || fullyQualifiedSelectedStates is null)
                {
                    WriteLog("Stopping split. No units of work selected.", Severity.Error);
                }
                else
                {
                    // the element names that are eligible for export
                    string[]? checkoutElementNames = null;
                    // the nodes that will be split off from the XML
                    XmlNode[]? nodes = null;
                    if (checkoutItems is not null && manualFromDocnbr is not null && xml.DocumentElement is not null && xml.DocumentElement.GetAttribute("docnbr") is string docnbr && !string.IsNullOrEmpty(program))
                    {
                        WriteLog($"Using checkout element names on {Path.GetFileName(xmlSourceFile)} to restrict XPath query by docnbr '{docnbr}'.");
                        XmlSplitterHelpers.Programs ofPrograms = Enum.Parse<XmlSplitterHelpers.Programs>(program);
                        string manual = manualFromDocnbr[ofPrograms][docnbr];
                        foreach (string manualNameKey in checkoutItems[ofPrograms].Keys)
                        {
                            XmlSplitterHelpers.bestMatch.Enqueue(manualNameKey, XmlSplitterHelpers.jaccard.Distance(manual, manualNameKey));
                        }

                        checkoutElementNames = checkoutItems[ofPrograms][XmlSplitterHelpers.bestMatch.Dequeue()];
                        nodes = await Task.Run(() => xml.SelectNodesByCheckout(xpath, checkoutElementNames));
                    }
                    else
                    {
                        WriteLog($"Not using checkout element names on {Path.GetFileName(xmlSourceFile)}. Using unmodified XPath query.");
                        if (await Task.Run(() => xml.SelectNodes(xpath)) is XmlNodeList nodeList)
                        {
                            nodes = nodeList.Cast<XmlNode>().ToArray();
                        }
                    }
                    if (nodes is not null && nodes.Length > 0)
                    {
                        WriteLog(string.Format("Splitting XML file '{0}' into {1} fragments", Path.GetFileName(xmlSourceFile), nodes.Length));
                        report = new(capacity: nodes.Length);
                        StringBuilder htmlReportBuilder = new();
                        _ = htmlReportBuilder.Append($"""
                        <!DOCTYPE html>
                        <html lang="en">
                        <head>
                            <meta charset="UTF-8">
                            <meta name="viewport" content="width=device-width, initial-scale=1.0">
                            <title>Report on Splitting {XmlSourceFileBaseName}</title>
                            <style>
                        """);
                        _ = htmlReportBuilder.Append("""
                                * {
                                    font-family: Aptos, Aptos_EmbeddedFont, Aptos_MSFontService, Calibri, Helvetica, sans-serif;
                                }
                                code {
                                    font-family: "Aptos Mono", Aptos_EmbeddedFont, Aptos_MSFontService, monospace;
                                }
                                table,
                                th,
                                td {
                                    border: 1px solid black;
                                    border-collapse: collapse;
                                    width: auto;
                                    text-wrap: pretty;
                                    overflow-wrap: anywhere;
                                }
                                th,
                                td {
                                    padding: 5px;
                                    text-align: left;
                                }

                                tr:nth-child(even) {
                                    background-color: #eee;
                                }

                                tr:nth-child(odd) {
                                    background-color: #fff;
                                }
                                aside {
                                    background-color: #e7f3fe;
                                    border-left: 6px solid #2196F3;
                                    text-align: left;
                                    padding: 4px;
                                    -webkit-box-shadow: 2px 2px 4px -1px rgba(0, 0, 0, 0.75);
                                    -moz-box-shadow: 2px 2px 4px -1px rgba(0, 0, 0, 0.75);
                                    box-shadow: 2px 2px 4px -1px rgba(0, 0, 0, 0.75);
                                    margin-bottom: 0.5em;
                                }
                                aside::before {
                                    content: "ⓘ";
                                    font-weight: bold;
                                    font-size: 1.5em;
                                    display: inline-block;
                                    line-height: 0.9em;
                                    color: #2196F3;
                                    text-shadow: 1px 1px 4px black;
                                    background-color: white;
                                    border-radius: 50%;
                                    margin-right: 0.4em;
                                }
                                pre {
                                    display: block;
                                    background: black;
                                    color: aliceblue;
                                    padding: 0.75em;
                                    min-height: 4vh;
                                }
                            </style>
                        </head>
                        """);
                        string dateTimeNow = DateTime.Now.ToString("yyyy - MM - dd - HH - mm - ss - fffffff");
                        string reportBaseFilename = $"{XmlSourceFileBaseName}SplittingReport - {dateTimeNow}";
                        string[] splittingReportFilenames = Enum.GetNames<XmlSplitReport.ReportFormat>().Select(format => $"{reportBaseFilename}.{format.ToLowerInvariant()}").ToArray();
                        _ = htmlReportBuilder.Append($"""
                        <body>
                            <p>The source XML, '{Path.GetFileName(xmlSourceFile)}', was split into {nodes.Length} unit of work nodes.</p>
                            <p>The complete splitting report is written as {string.Join(", ", Enum.GetNames<XmlSplitReport.ReportFormat>())} in the WIP package with the following file names:</p>
                            <ul>
                                {string.Join(Environment.NewLine, splittingReportFilenames.Select(filename => $"<li><see href=\"{new Uri(Path.Combine(outputDir, filename)).AbsoluteUri}\">{filename}</a></li>").ToArray())}
                            </ul>
                            <p>Below is the full HTML report of the XML splitting results:</p>
                            <table>
                                <caption><p>Table showing the details on each node that was split from the source XML.</p><aside aria-label="Information note">The tag of the parent is the <em>most recent containing XML node</em> having a <code>key</code> attribute; or, where there is no such <code>key</code>-bearing node, the root node for the document is indicated. For brevity, the parent tag is represented as a self-closing tag without inner XML.</aside><aside aria-label="Information note">"Node" in this context refers to the unit of work as an <see href="https://learn.microsoft.com/en-us/dotnet/api/system.xml.xmlnode?view=net-8.0"><code>XmlNode</code></a> that was split off from the source <see href="https://learn.microsoft.com/en-us/dotnet/api/system.xml.xmldocument?view=net-8.0"><code>XmlDocument</code></a>.</aside></caption>
                                <colgroup><col /><col /><col /><col /><col /><col /><col /><col /><col /><col /><col /><col /><col /></colgroup>
                                <tr>
                                    <th>Checkout Parent Number</th>
                                    <th>Checkout Parent Element's Name</th>
                                    <th>Checkout Parent's 'Key' Value</th>
                                    <th>Checkout Parent's Opening Tag</th>
                                    <th>UOW Node Number</th>
                                    <th>UOW Node Element's Name</th>
                                    <th>UOW Node's 'Key' Value</th>
                                    <th>Key-bearing Parent's Opening Tag</th>
                                    <th>Full XPath to UOW Node</th>
                                    <th>Filename of Split</th>
                                    <th>UOW State Value</th>
                                    <th>UOW State Name</th>
                                    <th>UOW State Remark</th>
                                </tr>
                        """);
                        if (fullyQualifiedSelectedStates.ToArray() is UowState[] sourceStates)
                        {
                            HashSet<XmlNode> notSeenNodes = new(sourceStates.Length);
                            Dictionary<XmlNode, List<(UowState, XmlNode)>> childrenPerCheckoutItem = new(nodes.Length);
                            for (int i = 0; i < sourceStates.Length; i++)
                            {
                                progressBar.Value = (int)(100 * (i + 1) / sourceStates.Length);
                                bool foundParent = false;
                                if (sourceStates[i] is UowState curState && curState.XPath is string curXPath && xml.SelectSingleNode(curXPath) is XmlNode curNode && notSeenNodes.Add(curNode))
                                {
                                    // find the node in nodes that is the parent of curNode
                                    foreach (XmlNode node in nodes)
                                    {
                                        if (XmlSplitterHelpers.IsDescendant(node, curNode))
                                        {
                                            foundParent = true;
                                            // append curNode to childrenPerCheckoutItem[node]
                                            if (childrenPerCheckoutItem.TryGetValue(node, out List<(UowState, XmlNode)>? value))
                                            {
                                                value.Add((curState, curNode));
                                            }
                                            else
                                            {
                                                childrenPerCheckoutItem.Add(node, [(curState, curNode)]);
                                            }
                                            break;
                                        }
                                    }
                                }
                                if (!foundParent && checkoutElementNames is not null && $"({string.Join('|', checkoutElementNames)})" is string checkoutElementsRe && Regex.IsMatch(sourceStates[i].TagName ?? string.Empty, checkoutElementsRe, RegexOptions.IgnoreCase))
                                {
                                    Debug.WriteLine($"Could not find the parent node for state {sourceStates[i]}");
                                }
                            }
                            int nodeNum = 1;
                            List<string> additionalMessages = [];
                            for (int i = 0; i < nodes.Length; i++)
                            {
                                BaXmlDocument xmlFragment = new()
                                {
                                    ResolveEntities = false
                                };
                                _ = await Task.Run(() => xmlFragment.AppendChild(xmlFragment.ImportNode(nodes[i], true)));
                                if (nodes[i].Attributes?["key"]?.Value is string key)
                                {
                                    string outPath = Path.Combine(outputDir, string.Format("{0}-{1}.xml", XmlSourceFileBaseName, key));
                                    // write the fragment to the outPath
                                    await Task.Run(() => xmlFragment.Save(outPath));
                                    WriteLog(string.Format("Wrote fragment to '{0}'", outPath), Severity.Hint);
                                    // create an entry per child on childrenPerCheckoutItem
                                    int numChildren = childrenPerCheckoutItem[nodes[i]].Count;
                                    for (int j = 0; j < numChildren; j++)
                                    {
                                        (UowState curState, XmlNode curNode) = childrenPerCheckoutItem[nodes[i]][j];
                                        XmlNode parentTag = XmlSplitterHelpers.CalculateParentTag(curNode);
                                        XmlSplitReportEntry reportEntry = new(checkoutParent: nodes[i], checkoutParentNumber: i + 1, nodeNumber: nodeNum++, uowNode: curNode, keyedParentTag: parentTag, fullXPath: GenerateUniqueXPath(curNode), filenameOfSplit: Path.GetFileName(outPath), uowState: curState);
                                        report.Add(reportEntry);
                                        _ = htmlReportBuilder.Append("<tr>");
                                        if (j == 0)
                                        {
                                            _ = htmlReportBuilder.AppendFormat(@"<!-- Checkout Parent Number --><td rowspan='{1}'>{0}</td>", reportEntry.CheckoutParentNumber, numChildren);
                                            _ = htmlReportBuilder.AppendFormat(@"<!-- Checkout Parent Name --><td rowspan='{1}'>{0}</td>", reportEntry.CheckoutParent.Name, numChildren);
                                            _ = htmlReportBuilder.AppendFormat(@"<!-- Checkout's 'Key' Value --><td>{0}</td>", reportEntry.CheckoutParent.Attributes?["key"]?.Value ?? "&nbsp;");
                                            _ = htmlReportBuilder.AppendFormat(@"<!-- Checkout Parent Tag --><td rowspan='{1}'><code>{0}</code></td>", HttpUtility.HtmlEncode(reportEntry.CheckoutParent.OuterXml), numChildren);
                                        }
                                        _ = htmlReportBuilder.AppendFormat(@"<!-- Node Number --><td>{0}</td>", reportEntry.NodeNumber);
                                        _ = htmlReportBuilder.AppendFormat(@"<!-- Node Element Name --><td>{0}</td>", reportEntry.UowNode.Name.ToString());
                                        _ = htmlReportBuilder.AppendFormat(@"<!-- Node's 'Key' Value --><td>{0}</td>", curNode.Attributes?["key"]?.Value is string curNodeKey ? curNodeKey : "&nbsp;");
                                        _ = htmlReportBuilder.AppendFormat(@"<!-- Key-bearing Parent's Tag --><td><code>{0}</code></td>", reportEntry.KeyedParent is null ? "&nbsp;" : HttpUtility.HtmlEncode(reportEntry.KeyedParent.OuterXml));
                                        _ = htmlReportBuilder.AppendFormat(@"<!-- Full XPath --><td><code>{0}</code></td>", HttpUtility.HtmlEncode(reportEntry.FullXPath));
                                        _ = htmlReportBuilder.AppendFormat(@"<!-- Filename of Split --><td>{0}</td>", reportEntry.FilenameOfSplit);
                                        _ = htmlReportBuilder.AppendFormat(@"<!-- ETPS UOW State Value --><td>{0}</td>", reportEntry.UowState.StateValue);
                                        _ = htmlReportBuilder.AppendFormat(@"<!-- ETPS UOW State Name --><td>{0}</td>", reportEntry.UowState.StateName);
                                        _ = htmlReportBuilder.AppendFormat(@"<!-- ETPS UOW State Remark --><td>{0}</td>", string.IsNullOrEmpty(reportEntry.UowState.Remark) ? "&nbsp;" : HttpUtility.HtmlEncode(reportEntry.UowState.Remark));
                                        _ = htmlReportBuilder.Append("</tr>");
                                        if (reportEntry.KeyedParent is not null)
                                        {
                                            bool keyedParentIsCheckoutParent = reportEntry.CheckoutParent.OuterXml is not null && reportEntry.KeyedParent.OuterXml == reportEntry.CheckoutParent.OuterXml;
                                            bool keyedParentIsUowNode = reportEntry.KeyedParent.Attributes?["key"]?.Value is not null && reportEntry.KeyedParent.Attributes?["key"]?.Value == reportEntry.UowNode.Attributes?["key"]?.Value && reportEntry.KeyedParent.Name == reportEntry.UowNode.Name;
                                            if (keyedParentIsCheckoutParent && keyedParentIsUowNode)
                                            {
                                                additionalMessages.Add($"Notice that the incremental revision unit-of-work node {reportEntry.NodeNumber} is a checkout node with a unique key ({reportEntry.UowNode.Attributes?["key"]?.Value}). This is why there is repetition of the key and tag values.");
                                            }
                                            else if (keyedParentIsCheckoutParent)
                                            {
                                                additionalMessages.Add($"Notice that the key-bearing parent on the unit-of-work node {reportEntry.NodeNumber} is also the checkout node. This is why the tag values (\"Checkout Parent's Opening Tag\" and \"Key-bearing Parent's Opening Tag\") are repeated.");
                                            }
                                            else if (keyedParentIsUowNode)
                                            {
                                                additionalMessages.Add($"Notice that the incremental revision unit-of-work node {reportEntry.NodeNumber} has a unique key ({reportEntry.UowNode.Attributes?["key"]?.Value}) the same as its parent. This is why there is repetition of the key value.");
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    WriteLog(string.Format("Unable to get 'key' attribute from node #{0} ({1}) on UOW #{2}. Skipping.", nodeNum, nodes[i].Name, i + 1), Severity.Warning);
                                }
                            }
                            _ = htmlReportBuilder.Append($"</table><p>{string.Join(' ', additionalMessages)}</p></body></html>");
                            splittingReportHtml = htmlReportBuilder.ToString();
                            WriteLog("Done splitting XML file. Showing results report.");
                            await Task.Run(() => GenerateOtherReports(reportBaseFilename));
                            // display the report in the default browser
                            await Task.Run(() => DisplayHtmlReport());

                        }
                    }

                }
                progressBar.Visible = false;
                stepsPanel.Controls.Remove(progressBar);
                execButton.Visible = true;
            }
        }

        /// <summary>
        /// Generates the XML, CSV, TSV reports.
        /// </summary>
        /// <param name="baseFilename">The base filename.</param>
        /// <returns></returns>
        private void GenerateOtherReports(string baseFilename)
        {
            if (report is not null && !string.IsNullOrEmpty(outputDir))
            {
                foreach (XmlSplitReport.ReportFormat format in Enum.GetValuesAsUnderlyingType<XmlSplitReport.ReportFormat>())
                {
                    string reportFilename = Path.Combine(outputDir, $"{baseFilename}.{Enum.GetName(format)}");
                    WriteLog($"Writing report to {reportFilename}");
                    report.Save(reportFilename, format);
                }
            }
        }

        /// <summary>
        /// Displays the HTML report.
        /// </summary>
        /// <returns></returns>
        private void DisplayHtmlReport()
        {
            if (string.IsNullOrEmpty(splittingReportHtml) || string.IsNullOrEmpty(xmlSourceFile))
            {
                WriteLog("No HTML report to display.", Severity.Warning);
                return;
            }
            string reportOutPath = Path.Combine(outDirTextBox.Text, $"Splitting{XmlSourceFileBaseName}Report-{DateTime.Now:yyyy-MM-dd-HH-mm-ss-fffffff}.html");
            WriteLog("Displaying HTML report using default browser.");
            try
            {
                File.WriteAllText(reportOutPath, splittingReportHtml);
                ProcessStartInfo psi = new()
                {
                    UseShellExecute = true,
                    FileName = reportOutPath
                };
                Process.Start(psi);
            }
            catch (Exception ex)
            {
                WriteLog(ex.ToString(), Severity.Error);
                return;
            }
            WriteLog($"Wrote XML splitting report to {reportOutPath}");
        }

        /// <summary>
        /// Generates the unique XPath for the XML node.
        /// </summary>
        /// <param name="xmlNode">The XML node.</param>
        /// <returns>An XPath for the given node.</returns>
        private string GenerateUniqueXPath(XmlNode xmlNode)
        {
            if (xmlNode.NodeType == XmlNodeType.Attribute && xmlNode is XmlAttribute xmlNodeAsAttrib && xmlNodeAsAttrib.OwnerElement is not null)
            {
                // attributes have an OwnerElement, not a ParentNode; also they have             
                // to be matched by name, not found by position
                return string.Format("{0}/@{1}", GenerateUniqueXPath(xmlNodeAsAttrib.OwnerElement), xmlNode.Name);
            }
            if (xmlNode.ParentNode is null)
            {
                // the only node with no parent is the root node, which has no path
                return string.Empty;
            }

            // Get the Index
            int indexInParent = 1;
            XmlNode? siblingNode = xmlNode.PreviousSibling;
            // Loop thru all Siblings
            while (siblingNode is not null)
            {
                // Increase the Index if the Sibling has the same Name
                if (siblingNode.Name == xmlNode.Name)
                {
                    indexInParent++;
                }
                siblingNode = siblingNode.PreviousSibling;
            }

            // the path to a node is the path to its parent, plus "/node()[n]", where n is its position among its siblings.         
            return string.Format("{0}/{1}[{2}]", GenerateUniqueXPath(xmlNode.ParentNode), xmlNode.Name, indexInParent);
        }

        /// <summary>
        /// Called when [drag drop].
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="DragEventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private void OnDragDrop(object sender, DragEventArgs e)
        {
            e.Effect = DragDropEffects.Copy;
            IDataObject? data = e.Data;
            if (data is not null && data.GetData(DataFormats.FileDrop) is not null)
            {
                if (data.GetData(DataFormats.FileDrop) is string[] paths)
                {
                    foreach (string path in paths.Distinct())
                    {
                        if (File.Exists(path))
                        {
                            if (Path.GetExtension(path).Equals(".xml", StringComparison.OrdinalIgnoreCase))
                            {

                                xmlSelectTextBox.Text = path;
                                XmlSelectTextBox_TextChanged(sender, e);
                            }
                            else
                            {
                                if (XmlSplitterHelpers.IsBinary(path) && !XmlSplitterHelpers.ShowConfirmationBox(string.Format("The file at '{0}' appears to be a binary file, not text. Continue?", path), string.Format("{0} appears to be binary", Path.GetFileName(path))))
                                {
                                    continue;
                                }
                                uowSelectBox.Text = path;
                                UowStatesTextBox_TextChanged(sender, e);
                            }
                        }
                        else if (Directory.Exists(path))
                        {
                            outDirTextBox.Text = path;
                            OutDirTextBox_TextChanged(sender, e);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Processes the unit-of-work states file.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private LogMessage[] ProcessUowStates(object sender, EventArgs e)
        {
            List<LogMessage> logMessages =
            [
                new LogMessage("Parsing units of work states file")
            ];
            UowState[]? states = XmlSplitterHelpers.ParseUowContent(uowContent, program, statesPerProgram, uowStatesFile, out List<LogMessage> parseUowLogMessages, out Hashtable statesInManual, out string impliedDocnbr);
            if (states is null)
            {
                logMessages.Add(new LogMessage("Not ready to process unit of work states. Check that UOW states file was loaded and parsed properly.", Severity.Warning));
            }
            else
            {
                // check that the root node name is the same as the uowStatesFileDocnbr
                if (xml.DocumentElement is null || string.IsNullOrEmpty(xml.DocumentElement.GetAttribute("docnbr")))
                {
                    logMessages.Add(new LogMessage("No root node docnbr identifiable in XML content. Please check the XML is correct.", Severity.Error));
                    return [.. logMessages];
                }
                else if (string.IsNullOrEmpty(impliedDocnbr))
                {
                    logMessages.Add(new LogMessage("The UOW states file was empty. Please check the UOW states file is correct.", Severity.Error));
                    return [.. logMessages];
                }
                else if (!xml.DocumentElement.GetAttribute("docnbr").Equals(impliedDocnbr, StringComparison.OrdinalIgnoreCase))
                {
                    logMessages.Add(new LogMessage(string.Format("Root node docnbr '{0}' does not match UOW states file docnbr '{1}'. Please check the UOW states file is correct.", xml.DocumentElement.GetAttribute("docnbr").ToUpperInvariant(), impliedDocnbr.ToUpperInvariant()), Severity.Error));
                    return [.. logMessages];
                }
                logMessages.Add(new LogMessage(string.Format("Found {0} distinct work states in the manual:\n\t{1}", statesInManual.Count, string.Join("\n\t", statesInManual.Values.Cast<UowState>().Select(uow => uow.ToString())))));
                IEnumerable<ListViewItem> items = statesInManual.Values.Cast<UowState>().ToArray().Select(state => new ListViewItem(new string[] { state.StateValue.ToString() ?? "", state.StateName ?? "", state.Remark ?? "" }));
                // display the multi select list view
                SelectStates dialog = new(items.ToArray(), states)
                {
                    Font = Font,
                    StartPosition = FormStartPosition.CenterParent,
                    Icon = Resources.Icon
                };
                _ = dialog.ShowDialog();
                if (dialog.DialogResult == DialogResult.OK)
                {
                    UowState[]? selectedStates = dialog.SelectedStates;
                    if (selectedStates is not null && selectedStates.Length > 0)
                    {
                        fullyQualifiedSelectedStates = states.Where((UowState state) => selectedStates.Select((UowState state) => state.StateValue).Contains(state.StateValue));
                        xpath = string.Join('|', fullyQualifiedSelectedStates.Select(state => state.XPath));
                        XPathTextBox_TextChanged(sender, e);
                    }
                    else
                    {
                        logMessages.Add(new LogMessage("No states chosen to split manual.", Severity.Warning));
                    }
                }
            }
            return [.. logMessages];
        }


        /// <summary>
        /// Programs the group box handler.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private void ProgramGroupBox(object sender, EventArgs e)
        {
            if ((string.IsNullOrEmpty(program) && !string.IsNullOrEmpty(programsComboBox.Text)) || (program != programsComboBox.Text && XmlSplitterHelpers.PROGRAMS.Contains(programsComboBox.Text)))
            {
                program = programsComboBox.Text;
                WriteLog($"program chosen for manual: {program}");
            }
            CheckExecuteSplitIsReady(sender, e);
        }

        private void mouseEnteredExecButton(object sender, EventArgs e)
        {
            if (!execButton.Enabled)
            {
                StringBuilder toolTipSb = new("Before executing the split,");
                if (!XmlIsSelected())
                {
                    _ = toolTipSb.AppendJoin(Environment.NewLine, "Select XML file");
                }
                if (!UowIsSelected())
                {
                    _ = toolTipSb.AppendJoin(Environment.NewLine, "Select UOW states file");
                }
                if (!OutDirIsSelected())
                {
                    _ = toolTipSb.AppendJoin(Environment.NewLine, "Select an output directory");
                }
                if (!ProgramIsSelected())
                {
                    _ = toolTipSb.AppendJoin(Environment.NewLine, "Select a program");
                }
                toolTip.SetToolTip(stepsPanel, toolTipSb.ToString());
            }
            else
            {
                toolTip.ToolTipIcon = ToolTipIcon.None;
                toolTip.SetToolTip(execButton, "Execute split");
            }
        }
        /// <summary>
        /// Mouse has left the execute button region.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <returns></returns>
        private void mouseLeftExecButton(object sender, EventArgs e)
        {
            toolTip.Hide(stepsPanel);
        }

    }
}
